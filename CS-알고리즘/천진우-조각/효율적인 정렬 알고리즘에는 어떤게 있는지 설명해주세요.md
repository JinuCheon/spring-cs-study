### 삽입 정렬(insert sort)

만약 이미 정렬되어 있는 상태라면, O(N)의 시간복잡도로 굉장히 효율적이다. 그러나 최악은 O(N2).

실제 비즈니스 문제에서는 이미 어느정도 정렬이 된 형태의 데이터가 많기 때문에, 경우에 따라 고려해볼만한 알고리즘.

### 퀵 정렬(quick sort)

임의의 기준값을 정하고 분할을 하면서 구하는 방식

분할 과정에서 logN 시간이 항상 발생

최선의 기준값을 선택하면 O(logN) + O(N) = O(NlogN) 매우 빠르지만,

최악의 경우 O(N2)..

불안정 정렬

### 힙 정렬(heap sort)

항상 O(NlogN)이라는 시간 복잡도.

추가 메모리가 필요하지 않음.

불안정 정렬

### 병합 정렬(merge sort)

항상 O(NlogN)이라는 시간 복잡도.

편차 없이 균일한 퍼포먼스를 내야하는 상황이라면, 좋은 알고리즘

그러나 추가적인 메모리 공간이 필요함.

안정적인 정렬!

### 불안정 정렬이란?

정렬 기준값이 똑같을 때, 같은 값끼리의 순서 보장이 되지 않음

### Reference

정렬 알고리즘 시각화

https://www.toptal.com/developers/sorting-algorithms